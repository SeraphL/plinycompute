\section{Object Model Tuning}

\noindent
The PC object model is designed for minimal-cost data movement, the result being that there is often no serialization or deserialization
cost
when moving PC \texttt{Object}'s across processes.  But memory management can still be costly.  Deallocating and cleaning
up complex objects (in particular, instances of container classes) can require significant CPU resources, which, depending upon the 
circumstance, may be un-necessary.  In-keeping with the assertion that application programmers should be in
control of performance-critical policies, it is possible to explicitly control how memory is reclaimed and re-used during PC computations.
This is facilitated through a set of \emph{allocation policies} that a programmer can choose from.

When the reference count for a PC \texttt{Object} located in a managed allocation block goes to zero, it is deallocated.  The exact
meaning of ``deallocated'' is controllable by the programmer, via a call to the \texttt{setAllocatorPolicy} on each computation object
that is created (\texttt{JoinComp}, \texttt{SelectionComp}, etc.).  Currently, PC ships with
three allocator policies:

\begin{enumerate}

\item Lightweight re-use.  This is the default policy.  When a PC \texttt{Object} is deallocated, its space in the allocation block is made available for re-use by
adding the space to a pool of similarly-sized, recycled memory chunks (all recycled chunks are organized into buckets, where a chunk of size
$n$ goes into bucket $\log_2 (n)$).  A request for RAM in a block is fulfilled by first scanning the recycled chunks in the appropriate bucket, then
attempting to allocate new space on the end of the block, if that fails.
\item No re-use.  The space containing deallocated PC \texttt{Object}s is not-reused.  Hence, it is very similar to classical, region-based allocation---though PC \texttt{Object}s
are reference-counted, and a destructor is called for each unreachable PC \texttt{Object}.
On the positive side, this allocation policy is very fast.  On the negative side, frequent allocations of temporary PC \texttt{Object}s will result in a lot of wasted space.
\item Recycling.  This is layered on top of lightweight re-use.  When the recycling allocator is used, any time a fixed-length
PC \texttt{Object} is deallocated, it is
added to a list of objects all having the same type.  All calls to \texttt{makeObject} with the zero-argument constructor will
pull an object off of the list of recyclable objects for the appropriate type.  
If an object is available for recycling, it is returned.  If not, or if any other constructor other than the zero-argument constructor is called, 
then the lightweight re-use allocator is used to allocate space for the requested
object.

\end{enumerate}

Note that
variable-length objects are never recycled.  There are just a few of these types in PC, and they are typically
used internally to implement the built-in PC container
types, and not by PC application programmers.  For example, PC's variable-length
\texttt{Array} class is used to implement the standard PC \texttt{Vector} container.  
These are not recycled because recycling allocations of such objects would need to match both on type and on size.  Matching on both at once would 
be computationally expensive, and could also allow long lists of objects to build up, waiting to be re-used.

In addition to policies that can be set on a per-computation basis,
it is also possible for a programmer to supply the following policies, on a per-\texttt{Object} bases, during PC \texttt{Object} allocation:

\begin{enumerate}

\item No reference counting.  This PC \texttt{Object} is not reference counted, and it is not included in the total count of objects on an allocation
block.  If each PC \texttt{Object} on an allocation block
is allocated in this way, this results in pure, region-based memory management, and is exceedingly lightweight.
\item Full reference counting.  This is the default.
\item Unique ownership.  The PC \texttt{Object} is not reference counted, but there can be one \texttt{Handle} object referencing the uniquely-owned
object.  When that \texttt{Handle} is destroyed, the object is deallocated.

\end{enumerate}


