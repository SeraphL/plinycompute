/*****************************************************************************
 *                                                                           *
 *  Copyright 2018 Rice University                                           *
 *                                                                           *
 *  Licensed under the Apache License, Version 2.0 (the "License");          *
 *  you may not use this file except in compliance with the License.         *
 *  You may obtain a copy of the License at                                  *
 *                                                                           *
 *      http://www.apache.org/licenses/LICENSE-2.0                           *
 *                                                                           *
 *  Unless required by applicable law or agreed to in writing, software      *
 *  distributed under the License is distributed on an "AS IS" BASIS,        *
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
 *  See the License for the specific language governing permissions and      *
 *  limitations under the License.                                           *
 *                                                                           *
 *****************************************************************************/

#include <PrologOptimizer.h>

/**
 * This file is created from the PrologToTCAP.pl so it can be embedded into pdb
 */
const std::string PrologOptimizer::prologToTCAPScript = "\n"
    "\n"
    "\n"
    "% Recursively traverse the query graph:\n"
    "bottomUpSearch(Node, Input, Projection, LeavesRemaining, ListofVisitedNodes):-\n"
    "\n"
    "\t% First we want to check:\n"
    "% If the node has been visited before?\n"
    "\n"
    "(member(Node, ListofVisitedNodes) ->\n"
    "\n"
    "\t% This \"Node\" has been visited before.\n"
    "\n"
    "\t\t% Check if any leaf node is still unexplored.\n"
    "\t\t% Start search from next leaf node.\n"
    "\t\t% Else we are done.\n"
    "\n"
    "\tlength(LeavesRemaining, LengthList),\n"
    "\t(LengthList \\= 0 ->\n"
    "\t\t[L|Rest] = LeavesRemaining,\n"
    "\t\tbottomUpSearch(L, [], [], Rest, ListofVisitedNodes)\n"
    ";\n"
    "true\n"
    "\t)\n"
    ";\n"
    "\n"
    "% The node has not been visited before.\n"
    "\n"
    "% Add this node to the list of visited.\n"
    "\tappend(ListofVisitedNodes, [Node], Visited),\n"
    "\n"
    "\n"
    "\t% Are we at root node?\n"
    "(Node = virtualRootNode ->\n"
    "\n"
    "\t% Start from next leaf node.\n"
    "\t\t\tlength(LeavesRemaining, LengthList),\n"
    "\t(LengthList \\= 0 ->\n"
    "\t\t[L|Rest] = LeavesRemaining,\n"
    "\t\tbottomUpSearch(L, [], [], Rest, Visited)\n"
    ";\n"
    "true\n"
    "\t)\n"
    ";\n"
    "\n"
    "% Else go up and explore the next compute node:\n"
    "\n"
    "node(Node,Y,CompName,KeyValueList),\n"
    "\n"
    "\t% Scan Node:\n"
    "(Y = scan ->\n"
    "\twrite(tcapOutput, Node),\n"
    "\tlink(Next,Node,Out,In,Project),\n"
    "\twrite(tcapOutput, \"(\"),printList(Out),write(tcapOutput, \")<= SCAN(\"),\n"
    "\tscan(Node,SetName,DBName),\n"
    "\tprintString(SetName),write(tcapOutput, \",\"),\n"
    "\tprintString(DBName),write(tcapOutput, \",\"),\n"
    "\tprintString(CompName),\n"
    "\twrite(tcapOutput, \", [\"), printKeyValueList(KeyValueList), write(tcapOutput, \"]\"),\n"
    "\twrite(tcapOutput, \")\\n\"),\n"
    "\tbottomUpSearch(Next, In, Project, LeavesRemaining, Visited)\n"
    "; true\n"
    "\t),\n"
    "\n"
    "\n"
    "\n"
    "% Apply Node:\n"
    "(Y = apply ->\n"
    "\tlink(Next,Node,Out,In,Project),\n"
    "\tapply(Node, InName, PrName, LName),\n"
    "\twrite(tcapOutput, Node),\n"
    "\twrite(tcapOutput, \"(\"),printList(Out),write(tcapOutput, \")<= APPLY(\"),\n"
    "\tprintNameListPair(InName, Input), write(tcapOutput, \",\"),\n"
    "\tprintNameListPair(PrName, Projection), write(tcapOutput, \",\"),\n"
    "\tprintString(CompName), write(tcapOutput, \",\"),\n"
    "\tprintString(LName),\n"
    "\twrite(tcapOutput, \", [\"), printKeyValueList(KeyValueList), write(tcapOutput, \"]\"),\n"
    "\twrite(tcapOutput, \")\\n\"),\n"
    "\tbottomUpSearch(Next, In, Project, LeavesRemaining, Visited)\n"
    "; true\n"
    "\t),\n"
    "\n"
    "\n"
    "% HashLeft Node:\n"
    "(Y = hashleft ->\n"
    "\twrite(tcapOutput, Node),\n"
    "\tlink(Next,Node,Out,In,Project),\n"
    "\twrite(tcapOutput, \"(\"),printList(Out),write(tcapOutput, \")<= HASHLEFT(\"),\n"
    "\thashleft(Node, InName, PrName, LName),\n"
    "\tprintNameListPair(InName, Input), write(tcapOutput, \",\"),\n"
    "\tprintNameListPair(PrName, Projection), write(tcapOutput, \",\"),\n"
    "\tprintString(CompName), write(tcapOutput, \",\"),\n"
    "\tprintString(LName),\n"
    "\twrite(tcapOutput, \", [\"), printKeyValueList(KeyValueList), write(tcapOutput, \"]\"),\n"
    "\twrite(tcapOutput, \")\\n\"),\n"
    "\tbottomUpSearch(Next, In, Project, LeavesRemaining, Visited)\n"
    "; true\n"
    "\t),\n"
    "\n"
    "\n"
    "% HashRight Node:\n"
    "(Y = hashright ->\n"
    "\twrite(tcapOutput, Node),\n"
    "\tlink(Next,Node,Out,In,Project),\n"
    "\twrite(tcapOutput, \"(\"),printList(Out),write(tcapOutput, \")<= HASHRIGHT(\"),\n"
    "\thashright(Node, InName, PrName, LName),\n"
    "\tprintNameListPair(InName, Input), write(tcapOutput, \",\"),\n"
    "\tprintNameListPair(PrName, Projection), write(tcapOutput, \",\"),\n"
    "\tprintString(CompName), write(tcapOutput, \",\"),\n"
    "\tprintString(LName),\n"
    "\twrite(tcapOutput, \", [\"), printKeyValueList(KeyValueList), write(tcapOutput, \"]\"),\n"
    "\twrite(tcapOutput, \")\\n\"),\n"
    "\tbottomUpSearch(Next, In, Project, LeavesRemaining, Visited)\n"
    "; true\n"
    "\t),\n"
    "\n"
    "\n"
    "% Join Node:\n"
    "(Y = join ->\n"
    "\tlink(Next,Node,Out,In,Project),\n"
    "\twrite(tcapOutput, Node),\n"
    "\twrite(tcapOutput, \"(\"),printList(Out),write(tcapOutput, \")<= JOIN(\"),\n"
    "\tjoin(Node, LeftInName, LeftPrName, RightInName, RightPrName),\n"
    "\tlink(Node, LeftInName, _, LeftIn, LeftProject),\n"
    "\tlink(Node, RightInName, _, RightIn, RightProject),\n"
    "\tprintNameListPair(LeftInName, LeftIn), write(tcapOutput, \",\"),\n"
    "\tprintNameListPair(LeftPrName, LeftProject), write(tcapOutput, \",\"),\n"
    "\tprintNameListPair(RightInName, RightIn), write(tcapOutput, \",\"),\n"
    "\tprintNameListPair(RightPrName, RightProject), write(tcapOutput, \",\"),\n"
    "\tprintString(CompName),\n"
    "\twrite(tcapOutput, \", [\"), printKeyValueList(KeyValueList), write(tcapOutput, \"]\"),\n"
    "\twrite(tcapOutput, \")\\n\"),\n"
    "\tbottomUpSearch(Next, In, Project, LeavesRemaining, Visited)\n"
    "; true\n"
    "\t),\n"
    "\n"
    "\n"
    "% Filter Node:\n"
    "(Y = filter ->\n"
    "\twrite(tcapOutput, Node),\n"
    "\tlink(Next,Node,Out,In,Project),\n"
    "\twrite(tcapOutput, \"(\"),printList(Out),write(tcapOutput, \")<= FILTER(\"),\n"
    "\tfilter(Node, InName, PrName),\n"
    "\tprintNameListPair(InName, Input), write(tcapOutput, \",\"),\n"
    "\tprintNameListPair(PrName, Projection), write(tcapOutput, \",\"),\n"
    "\tprintString(CompName),\n"
    "\twrite(tcapOutput, \", [\"), printKeyValueList(KeyValueList), write(tcapOutput, \"]\"),\n"
    "\twrite(tcapOutput, \")\\n\"),\n"
    "\tbottomUpSearch(Next, In, Project, LeavesRemaining, Visited)\n"
    "; true\n"
    "\t),\n"
    "\n"
    "\n"
    "% Hashone Node:\n"
    "(Y = hashone ->\n"
    "\twrite(tcapOutput, Node),\n"
    "\tlink(Next,Node,Out,In,Project),\n"
    "\twrite(tcapOutput, \"(\"),printList(Out),write(tcapOutput, \")<= HASHONE(\"),\n"
    "\thashone(Node, InName, PrName),\n"
    "\tprintNameListPair(InName, Input), write(tcapOutput, \",\"),\n"
    "\tprintNameListPair(PrName, Projection), write(tcapOutput, \",\"),\n"
    "\tprintString(CompName),\n"
    "\twrite(tcapOutput, \", [\"), printKeyValueList(KeyValueList), write(tcapOutput, \"]\"),\n"
    "\twrite(tcapOutput, \")\\n\"),\n"
    "\tbottomUpSearch(Next, In, Project, LeavesRemaining, Visited)\n"
    "; true\n"
    "\t),\n"
    "\n"
    "\n"
    "% Flatten Node:\n"
    "(Y = flatten ->\n"
    "\twrite(tcapOutput, Node),\n"
    "\tlink(Next,Node,Out,In,Project),\n"
    "\twrite(tcapOutput, \"(\"),printList(Out),write(tcapOutput, \")<= FLATTEN(\"),\n"
    "\tflatten(Node, InName, PrName),\n"
    "\tprintNameListPair(InName, Input), write(tcapOutput, \",\"),\n"
    "\tprintNameListPair(PrName, Projection), write(tcapOutput, \",\"),\n"
    "\tprintString(CompName),\n"
    "\twrite(tcapOutput, \", [\"), printKeyValueList(KeyValueList), write(tcapOutput, \"]\"),\n"
    "\twrite(tcapOutput, \")\\n\"),\n"
    "\tbottomUpSearch(Next, In, Project, LeavesRemaining, Visited)\n"
    "; true\n"
    "\t),\n"
    "\n"
    "\n"
    "% Output Node:\n"
    "(Y = output ->\n"
    "\twrite(tcapOutput, Node),\n"
    "\tlink(Next,Node,Out,In,Project),\n"
    "\twrite(tcapOutput, \"(\"),printList(Out),write(tcapOutput, \")<= OUTPUT(\"),\n"
    "\toutput(Node, InName, SetName,DBName),\n"
    "\tprintNameListPair(InName, Input), write(tcapOutput, \",\"),\n"
    "\tprintString(SetName),write(tcapOutput, \",\"),\n"
    "\tprintString(DBName),write(tcapOutput, \",\"),\n"
    "\tprintString(CompName),\n"
    "\twrite(tcapOutput, \", [\"), printKeyValueList(KeyValueList), write(tcapOutput, \"]\"),\n"
    "\twrite(tcapOutput, \")\\n\"),\n"
    "\tbottomUpSearch(Next, In, Project, LeavesRemaining, Visited)\n"
    "; true\n"
    "\t),\n"
    "\n"
    "\n"
    "% Aggregate Node:\n"
    "(Y = aggregate ->\n"
    "\twrite(tcapOutput, Node),\n"
    "\tlink(Next,Node,Out,In,Project),\n"
    "\twrite(tcapOutput, \"(\"),printList(Out),write(tcapOutput, \")<= AGGREGATE(\"),\n"
    "\taggregate(Node, InName),\n"
    "\tprintNameListPair(InName, Input), write(tcapOutput, \",\"),\n"
    "\tprintString(CompName),\n"
    "\twrite(tcapOutput, \", [\"), printKeyValueList(KeyValueList), write(tcapOutput, \"]\"),\n"
    "\twrite(tcapOutput, \")\\n\"),\n"
    "\tbottomUpSearch(Next, In, Project, LeavesRemaining, Visited)\n"
    "; true\n"
    "\t)\n"
    "\t)\n"
    "\t).\n"
    "\n"
    "% Find the leaves:\n"
    "findLeaves(Leaves):-\n"
    "\tfindall(X0, scan(X0,_,_), Leaves).\n"
    "\n"
    "\n"
    "\t% TCAP generator:\n"
    "tcapGenerator:-\n"
    "\topen('tcapOutput.tcap', write, ID, [alias(tcapOutput)]),\n"
    "\tfindLeaves([H|T]),\n"
    "\tbottomUpSearch(H, [], [], T, []),\n"
    "\tclose(ID).\n"
    "\n"
    "getFile(FileName):-\n"
    "    absolute_file_name('tcapOutput.tcap', FileName).\n"
    "\n"
    "\t\t% Print name-list pair: TCAP:\n"
    "printNameListPair(ListName, List):-\n"
    "\twrite(tcapOutput, ListName), write(tcapOutput, \"(\"), printList(List), write(tcapOutput, \")\").\n"
    "\n"
    "\n"
    "\t% Print string to console: 'String'\n"
    "printString(String):-\n"
    "\twrite(tcapOutput, \"'\"),write(tcapOutput, String),write(tcapOutput, \"'\").\n"
    "\n"
    "\t% Print list to console:\n"
    "printList([]).\n"
    "\tprintList([H|T]):-\n"
    "\twrite(tcapOutput, H),\n"
    "\tlength(T, Len),\n"
    "\t(\tLen \\= 0 -> write(tcapOutput, \",\")\n"
    "; true\n"
    "\t),\n"
    "printList(T).\n"
    "\n"
    "\n"
    "\n"
    "\t% Print KeyValueList to console:\n"
    "printKeyValueList([]).\n"
    "\tprintKeyValueList([H|T]):-\n"
    "\tH = (A,B),\n"
    "\twrite(tcapOutput, \"(\"), printString(A),write(tcapOutput, \",\"),printString(B),write(tcapOutput, \")\"),\n"
    "\tlength(T, Len),\n"
    "\t(\tLen \\= 0 -> write(tcapOutput, \",\")\n"
    "; true\n"
    "\t),\n"
    "printKeyValueList(T).";