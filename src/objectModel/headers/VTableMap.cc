/*****************************************************************************
 *                                                                           *
 *  Copyright 2018 Rice University                                           *
 *                                                                           *
 *  Licensed under the Apache License, Version 2.0 (the "License");          *
 *  you may not use this file except in compliance with the License.         *
 *  You may obtain a copy of the License at                                  *
 *                                                                           *
 *      http://www.apache.org/licenses/LICENSE-2.0                           *
 *                                                                           *
 *  Unless required by applicable law or agreed to in writing, software      *
 *  distributed under the License is distributed on an "AS IS" BASIS,        *
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
 *  See the License for the specific language governing permissions and      *
 *  limitations under the License.                                           *
 *                                                                           *
 *****************************************************************************/

#include "Object.h"
#include "Nothing.h"

#ifndef PDBCATALOG_VTABLEMAP_C_
#define PDBCATALOG_VTABLEMAP_C_

/*
 * VTableMap.cc
 *
 *  Created on: Dec 11, 2015
 *      Author: carlos
 */

// This header is auto-generated by SConstruct... it includes all of the header files
// in BuiltInPDBObjects/headers

#include <dlfcn.h>
#include <LockGuard.h>
#include <unistd.h>
#include "PDBCommunicator.h"
#include <cctype>
#include "PDBCatalogClient.h"

namespace pdb {

    // returns the number of registered built-in objects
inline int VTableMap :: totalBuiltInObjects () {
        int count = 0;
        for (int i = 0; i < theVTable->allVTables.size();i++){
            if (theVTable->allVTables[i] != nullptr){
                count = count + 1;
            }

        }
        return count;
}

inline void VTableMap :: listVtableEntries () {
        for (int i=0;i< theVTable->allVTables.size();i++){
            if (theVTable->allVTables[i] != nullptr) std::cout << "vtpr " << i << ": " << theVTable->allVTables[i] << std::endl;
        }
}    

inline void VTableMap :: listVtableLabels () {
        std::map<std::string, int16_t> iterator;

        for(auto &iterator : theVTable->objectTypeNamesList){
            std::cout << "label= " << iterator.first << " id= " <<  iterator.second << std::endl;
        }
}

inline int16_t VTableMap :: getIDByName (std::string objectTypeName) {

	    // find the first instance of '<' so that we can strip out any template argument
            size_t loc = objectTypeName.find_first_of ("<");

	    // strip out the template argument and replace with "<pdb::Nothing>"
	    if (loc != std::string::npos) {
		objectTypeName = objectTypeName.substr (0, loc) + "<pdb::Nothing>";
	    }

	    // now, check to make sure that we have seen the given object type before
	    if (theVTable->objectTypeNamesList.count (objectTypeName) == 0 && theVTable->parent != nullptr) {
			
			// in this case, we do not have this object type, and we have never looked for it before
			// so, go to the catalog and ask for it...
			int16_t identifier = theVTable->parent->searchForObjectTypeName (objectTypeName);

			// make sure no one is modifying the map
			const LockGuard guard {theVTable->myLock};
		
			// if the identifier is -1, then it means the catalog has never seen this type before
			// so let the caller know, and remember that we have not seen it
			if (identifier == -1) {
				theVTable->objectTypeNamesList[objectTypeName] = -1;
				return -1;

			// otherwise, return the ID
			} else {
				theVTable->objectTypeNamesList[objectTypeName] = identifier;
				return identifier;
			}

		// in the easy case, we have seen it before, so just return the typeID
		} else {
			return theVTable->objectTypeNamesList[objectTypeName];	
		}
}

inline void *VTableMap :: getVTablePtr (int16_t objectTypeID) {
        // there are two cases; first, we already have the vTable pointer for this guy
        return theVTable->allVTables[objectTypeID];

	// TO DO: deal with the case when the pointer is not there... need to get it from a catalog
}

inline void *VTableMap :: getVTablePtr (int16_t objectTypeID, std::string typeName) {
		// there are two cases; first, we already have the vTable pointer for this guy
		void *vTablePtr = theVTable->allVTables[objectTypeID];
		if (vTablePtr != nullptr) {
			return vTablePtr;
		}

		// make sure no one is modifying the vector
		const LockGuard guard {theVTable->myLock};
		
		// in the second case, we do not have the vTable pointer for this guy, so we will try to load it
		if (theVTable->parent == nullptr || !(theVTable->parent->getSharedLibrary (objectTypeID, typeName, "data_types"))) {
			if (theVTable->logger != nullptr)
				theVTable->logger->writeLn ("unable to obtain shared library file.");
			return nullptr;
		}

		// otherwise, we will go ahead and get this type's vTable pointer
		std::string errorMessage;
		theVTable->allVTables[objectTypeID] = theVTable->getVTablePtr (typeName, errorMessage);

		// we also set the map accordingly
        	theVTable->objectTypeNamesList[typeName] = objectTypeID;
			
		// write the result to the logger
		if (theVTable->allVTables[objectTypeID] != nullptr && theVTable->logger != nullptr) {
			theVTable->logger->writeLn ("successfully loaded type " + typeName + " into memory.");
		} else if (theVTable->logger != nullptr) {
			theVTable->logger->writeLn ("unable to load shared library into memory.");
			theVTable->logger->writeLn ("error was " + errorMessage);
			return nullptr;
		}

		//TODO handle removal of files
		// remove the shared library file and get outta here
		// if (unlink ("./bin/libTestSoObject.so") != 0) {
		// 	getLogger ()->writeLn ("Error trying to remove the files containing the shared library.");
		// 	return nullptr;
		// }

		// return the pointer we found
		return theVTable->allVTables[objectTypeID];
}

inline void *VTableMap :: getVTablePtr (std::string typeName, std::string &errorMessage) {

		void *so_handle = NULL;
		std::string sharedLibraryFile = "bin/lib" + typeName + ".so";

		// open up the shared library
		so_handle = dlopen(sharedLibraryFile.c_str(), RTLD_LOCAL | RTLD_LAZY );

		Object *object = nullptr;

		if (!so_handle) {
			const char* dlsym_error = dlerror();
			errorMessage = "Cannot load Stored Data Type library: " + sharedLibraryFile + " error " + (std::string)dlsym_error + '\n';

		// if we were able to open it
		} else {
			const char* dlsym_error = dlerror();

			// get the function that will give us access to the vTable
			typedef Object *GetObjectFunc ();
			std::string getInstance = typeName + "_getInstance";

			GetObjectFunc *getObjectFunc = (GetObjectFunc *) dlsym(so_handle, getInstance.c_str());

			// see if we were able to get the function
			if ((dlsym_error = dlerror())) {
				errorMessage = "Error, can't load function getInstance (); error is " + (std::string)dlsym_error + "\n";

			// if we were able to, then run it
			} else {
				object = getObjectFunc ();
			}
		}

		return object->getVTablePtr ();
}

} /* namespace pdb */

#endif
